# CCO (Claude Code Orchestrator) Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use Skill(executing-plans) to implement this plan task-by-task.

**Goal:** Build a Go CLI (`cco`) that replicates CWM's worktree/tmux/Claude orchestration with centralized session storage under XDG.

**Architecture:** Go binary using cobra for CLI, shelling out to git and tmux. Internal packages: `paths` (pure functions), `git` (worktree ops), `tmux` (session/window ops), `session` (orchestration). Sessions stored at `$XDG_DATA_HOME/cco/sessions/{repo}/{branch}/`. See `.plans/2026-02-20-cco-architecture.md` for full architecture.

**Tech Stack:** Go, cobra (CLI framework), git (shelled out), tmux (shelled out)

**Reference:** The existing Python implementation is at `scripts/cwm` and its tests at `tests/test_cwm.py`. Use these as behavioral references â€” the Go implementation should match CWM's behavior unless noted otherwise.

---

### Task 1: Project scaffolding and root command

**Files:**
- Create: `orchestrator/go.mod`
- Create: `orchestrator/main.go`
- Create: `orchestrator/cmd/root.go`

**Step 1: Initialize Go module**

Run:
```bash
cd orchestrator && go mod init github.com/averycrespi/claudefiles/orchestrator
```

**Step 2: Install cobra**

Run:
```bash
cd orchestrator && go get github.com/spf13/cobra@latest
```

**Step 3: Write main.go**

```go
package main

import "github.com/averycrespi/claudefiles/orchestrator/cmd"

func main() {
	cmd.Execute()
}
```

**Step 4: Write root command**

```go
package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
	Use:   "cco",
	Short: "Claude Code Orchestrator - manage parallel Claude Code sessions",
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
```

**Step 5: Build and verify**

Run:
```bash
cd orchestrator && go build -o cco . && ./cco --help
```
Expected: Help output showing "Claude Code Orchestrator" and no subcommands yet.

**Step 6: Commit**

```bash
git add orchestrator/
git commit -m "feat(cco): scaffold Go project with cobra root command"
```

---

### Task 2: Paths package

**Files:**
- Create: `orchestrator/internal/paths/paths.go`
- Create: `orchestrator/internal/paths/paths_test.go`

**Step 1: Write failing tests**

```go
package paths

import (
	"os"
	"testing"
)

func TestDataDir_Default(t *testing.T) {
	os.Unsetenv("XDG_DATA_HOME")
	dir := DataDir()
	home, _ := os.UserHomeDir()
	expected := home + "/.local/share/cco"
	if dir != expected {
		t.Errorf("DataDir() = %q, want %q", dir, expected)
	}
}

func TestDataDir_XDG(t *testing.T) {
	t.Setenv("XDG_DATA_HOME", "/custom/data")
	dir := DataDir()
	if dir != "/custom/data/cco" {
		t.Errorf("DataDir() = %q, want %q", dir, "/custom/data/cco")
	}
}

func TestSessionDir(t *testing.T) {
	t.Setenv("XDG_DATA_HOME", "/data")
	dir := SessionDir("myapp", "feat/thing")
	expected := "/data/cco/sessions/myapp/feat-thing"
	if dir != expected {
		t.Errorf("SessionDir() = %q, want %q", dir, expected)
	}
}

func TestSanitizeBranch(t *testing.T) {
	tests := []struct {
		input, want string
	}{
		{"feat/my-thing", "feat-my-thing"},
		{"simple", "simple"},
		{"a/b/c", "a-b-c"},
		{"feat_underscore", "feat-underscore"},
		{"UPPER/case", "UPPER-case"},
	}
	for _, tt := range tests {
		got := SanitizeBranch(tt.input)
		if got != tt.want {
			t.Errorf("SanitizeBranch(%q) = %q, want %q", tt.input, got, tt.want)
		}
	}
}

func TestTmuxSessionName(t *testing.T) {
	name := TmuxSessionName("myapp")
	if name != "myapp-worktree" {
		t.Errorf("TmuxSessionName() = %q, want %q", name, "myapp-worktree")
	}
}

func TestTmuxWindowName(t *testing.T) {
	name := TmuxWindowName("feat/thing")
	if name != "feat-thing" {
		t.Errorf("TmuxWindowName() = %q, want %q", name, "feat-thing")
	}
}
```

**Step 2: Run tests to verify they fail**

Run:
```bash
cd orchestrator && go test ./internal/paths/
```
Expected: Compilation error â€” package has no Go files yet.

**Step 3: Write implementation**

```go
package paths

import (
	"os"
	"path/filepath"
	"regexp"
)

var nonAlphanumericDash = regexp.MustCompile(`[^a-zA-Z0-9-]`)

// DataDir returns the base CCO data directory.
// Uses $XDG_DATA_HOME/cco or defaults to ~/.local/share/cco.
func DataDir() string {
	base := os.Getenv("XDG_DATA_HOME")
	if base == "" {
		home, _ := os.UserHomeDir()
		base = filepath.Join(home, ".local", "share")
	}
	return filepath.Join(base, "cco")
}

// SessionDir returns the full path to a session's worktree directory.
func SessionDir(repo, branch string) string {
	return filepath.Join(DataDir(), "sessions", repo, SanitizeBranch(branch))
}

// SanitizeBranch replaces non-alphanumeric characters (except hyphens) with hyphens.
func SanitizeBranch(branch string) string {
	return nonAlphanumericDash.ReplaceAllString(branch, "-")
}

// TmuxSessionName returns the tmux session name for a repository.
func TmuxSessionName(repo string) string {
	return repo + "-worktree"
}

// TmuxWindowName returns the tmux window name for a branch.
func TmuxWindowName(branch string) string {
	return SanitizeBranch(branch)
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
cd orchestrator && go test ./internal/paths/ -v
```
Expected: All 6 tests pass.

**Step 5: Commit**

```bash
git add orchestrator/internal/paths/
git commit -m "feat(cco): add paths package with XDG and name sanitization"
```

---

### Task 3: Git package

**Files:**
- Create: `orchestrator/internal/git/git.go`
- Create: `orchestrator/internal/git/git_test.go`

**Step 1: Write failing tests**

These are integration tests that create real git repos in temp directories.

```go
package git

import (
	"os"
	"os/exec"
	"path/filepath"
	"testing"
)

// helper: create a temp git repo with an initial commit
func setupRepo(t *testing.T) string {
	t.Helper()
	dir := t.TempDir()
	run(t, dir, "git", "init")
	run(t, dir, "git", "commit", "--allow-empty", "-m", "init")
	return dir
}

func run(t *testing.T, dir string, name string, args ...string) {
	t.Helper()
	cmd := exec.Command(name, args...)
	cmd.Dir = dir
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("%s %v failed: %s\n%s", name, args, err, out)
	}
}

func TestRepoInfo_MainRepo(t *testing.T) {
	dir := setupRepo(t)
	info, err := RepoInfo(dir)
	if err != nil {
		t.Fatalf("RepoInfo() error: %v", err)
	}
	if info.Name != filepath.Base(dir) {
		t.Errorf("Name = %q, want %q", info.Name, filepath.Base(dir))
	}
	if info.Root != dir {
		t.Errorf("Root = %q, want %q", info.Root, dir)
	}
	if info.IsWorktree {
		t.Error("IsWorktree = true, want false")
	}
}

func TestRepoInfo_NotARepo(t *testing.T) {
	dir := t.TempDir()
	_, err := RepoInfo(dir)
	if err == nil {
		t.Error("RepoInfo() expected error for non-repo dir")
	}
}

func TestBranchExists(t *testing.T) {
	dir := setupRepo(t)
	// main/master branch should exist after initial commit
	// Check which default branch was created
	info, _ := RepoInfo(dir)
	_ = info

	// Create a known branch
	run(t, dir, "git", "branch", "test-branch")
	if !BranchExists(dir, "test-branch") {
		t.Error("BranchExists(test-branch) = false, want true")
	}
	if BranchExists(dir, "nonexistent") {
		t.Error("BranchExists(nonexistent) = true, want false")
	}
}

func TestAddWorktree(t *testing.T) {
	dir := setupRepo(t)
	wtDir := filepath.Join(t.TempDir(), "wt")
	err := AddWorktree(dir, wtDir, "new-branch")
	if err != nil {
		t.Fatalf("AddWorktree() error: %v", err)
	}
	// Verify worktree directory exists and has .git
	if _, err := os.Stat(filepath.Join(wtDir, ".git")); os.IsNotExist(err) {
		t.Error("worktree .git file not created")
	}
	// Verify it's detected as a worktree
	info, err := RepoInfo(wtDir)
	if err != nil {
		t.Fatalf("RepoInfo(worktree) error: %v", err)
	}
	if !info.IsWorktree {
		t.Error("IsWorktree = false, want true")
	}
}

func TestAddWorktree_ExistingBranch(t *testing.T) {
	dir := setupRepo(t)
	run(t, dir, "git", "branch", "existing")
	wtDir := filepath.Join(t.TempDir(), "wt")
	err := AddWorktree(dir, wtDir, "existing")
	if err != nil {
		t.Fatalf("AddWorktree() error: %v", err)
	}
	if _, err := os.Stat(filepath.Join(wtDir, ".git")); os.IsNotExist(err) {
		t.Error("worktree .git file not created")
	}
}

func TestRemoveWorktree(t *testing.T) {
	dir := setupRepo(t)
	wtDir := filepath.Join(t.TempDir(), "wt")
	AddWorktree(dir, wtDir, "rm-branch")
	err := RemoveWorktree(dir, wtDir)
	if err != nil {
		t.Fatalf("RemoveWorktree() error: %v", err)
	}
	if _, err := os.Stat(wtDir); !os.IsNotExist(err) {
		t.Error("worktree directory still exists after removal")
	}
}
```

**Step 2: Run tests to verify they fail**

Run:
```bash
cd orchestrator && go test ./internal/git/
```
Expected: Compilation error â€” package has no Go files yet.

**Step 3: Write implementation**

```go
package git

import (
	"fmt"
	"os/exec"
	"path/filepath"
	"strings"
)

// Info contains information about a git repository.
type Info struct {
	Name       string // Repository directory name
	Root       string // Absolute path to repository root
	IsWorktree bool   // True if path is inside a worktree (not the main repo)
}

// RepoInfo returns information about the git repository at the given path.
func RepoInfo(path string) (Info, error) {
	// Check if inside a git repo
	cmd := exec.Command("git", "rev-parse", "--is-inside-work-tree")
	cmd.Dir = path
	if out, err := cmd.CombinedOutput(); err != nil {
		return Info{}, fmt.Errorf("not a git repository: %s", strings.TrimSpace(string(out)))
	}

	// Get repo root
	cmd = exec.Command("git", "rev-parse", "--show-toplevel")
	cmd.Dir = path
	out, err := cmd.Output()
	if err != nil {
		return Info{}, fmt.Errorf("could not determine repo root: %w", err)
	}
	root := strings.TrimSpace(string(out))

	// Check if this is a worktree or main repo
	cmd = exec.Command("git", "rev-parse", "--git-common-dir")
	cmd.Dir = path
	out, err = cmd.Output()
	if err != nil {
		return Info{}, fmt.Errorf("could not determine git common dir: %w", err)
	}
	commonDir := strings.TrimSpace(string(out))
	isWorktree := commonDir != ".git"

	return Info{
		Name:       filepath.Base(root),
		Root:       root,
		IsWorktree: isWorktree,
	}, nil
}

// BranchExists checks if a local branch exists.
func BranchExists(repoRoot, branch string) bool {
	cmd := exec.Command("git", "show-ref", "--verify", "--quiet", "refs/heads/"+branch)
	cmd.Dir = repoRoot
	return cmd.Run() == nil
}

// AddWorktree creates a git worktree at the given path.
// If the branch exists locally, it checks it out. Otherwise, it creates a new branch.
func AddWorktree(repoRoot, path, branch string) error {
	if BranchExists(repoRoot, branch) {
		cmd := exec.Command("git", "worktree", "add", "--quiet", path, branch)
		cmd.Dir = repoRoot
		out, err := cmd.CombinedOutput()
		if err != nil {
			return fmt.Errorf("git worktree add failed: %s", strings.TrimSpace(string(out)))
		}
	} else {
		cmd := exec.Command("git", "worktree", "add", "--quiet", "-b", branch, path)
		cmd.Dir = repoRoot
		out, err := cmd.CombinedOutput()
		if err != nil {
			return fmt.Errorf("git worktree add -b failed: %s", strings.TrimSpace(string(out)))
		}
	}
	return nil
}

// RemoveWorktree removes a git worktree at the given path.
func RemoveWorktree(repoRoot, path string) error {
	cmd := exec.Command("git", "worktree", "remove", path)
	cmd.Dir = repoRoot
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("git worktree remove failed: %s", strings.TrimSpace(string(out)))
	}
	return nil
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
cd orchestrator && go test ./internal/git/ -v
```
Expected: All 6 tests pass.

**Step 5: Commit**

```bash
git add orchestrator/internal/git/
git commit -m "feat(cco): add git package for repo info and worktree operations"
```

---

### Task 4: Tmux package

**Files:**
- Create: `orchestrator/internal/tmux/tmux.go`
- Create: `orchestrator/internal/tmux/tmux_test.go`

**Step 1: Write failing tests**

These are integration tests that create real tmux sessions.

```go
package tmux

import (
	"testing"
)

// Use a unique session name per test to avoid collisions
func testSession(t *testing.T) string {
	t.Helper()
	name := "cco-test-" + t.Name()
	t.Cleanup(func() {
		// Best-effort cleanup
		KillSession(name)
	})
	return name
}

func TestCreateSession(t *testing.T) {
	session := testSession(t)
	if SessionExists(session) {
		t.Fatal("session should not exist before creation")
	}
	if err := CreateSession(session, "main"); err != nil {
		t.Fatalf("CreateSession() error: %v", err)
	}
	if !SessionExists(session) {
		t.Error("session should exist after creation")
	}
}

func TestWindowExists(t *testing.T) {
	session := testSession(t)
	CreateSession(session, "main")
	if !WindowExists(session, "main") {
		t.Error("main window should exist")
	}
	if WindowExists(session, "nonexistent") {
		t.Error("nonexistent window should not exist")
	}
}

func TestCreateWindow(t *testing.T) {
	session := testSession(t)
	CreateSession(session, "main")
	dir := t.TempDir()
	if err := CreateWindow(session, "test-win", dir); err != nil {
		t.Fatalf("CreateWindow() error: %v", err)
	}
	if !WindowExists(session, "test-win") {
		t.Error("test-win should exist after creation")
	}
}

func TestKillWindow(t *testing.T) {
	session := testSession(t)
	CreateSession(session, "main")
	dir := t.TempDir()
	CreateWindow(session, "kill-me", dir)
	if err := KillWindow(session, "kill-me"); err != nil {
		t.Fatalf("KillWindow() error: %v", err)
	}
	if WindowExists(session, "kill-me") {
		t.Error("kill-me should not exist after KillWindow")
	}
}

func TestListWindows(t *testing.T) {
	session := testSession(t)
	CreateSession(session, "main")
	dir := t.TempDir()
	CreateWindow(session, "win-a", dir)
	CreateWindow(session, "win-b", dir)
	windows, err := ListWindows(session)
	if err != nil {
		t.Fatalf("ListWindows() error: %v", err)
	}
	found := map[string]bool{}
	for _, w := range windows {
		found[w] = true
	}
	for _, want := range []string{"main", "win-a", "win-b"} {
		if !found[want] {
			t.Errorf("ListWindows() missing %q, got %v", want, windows)
		}
	}
}

func TestRenameWindow(t *testing.T) {
	session := testSession(t)
	CreateSession(session, "main")
	dir := t.TempDir()
	CreateWindow(session, "old-name", dir)
	if err := RenameWindow(session, "old-name", "new-name"); err != nil {
		t.Fatalf("RenameWindow() error: %v", err)
	}
	if WindowExists(session, "old-name") {
		t.Error("old-name should not exist after rename")
	}
	if !WindowExists(session, "new-name") {
		t.Error("new-name should exist after rename")
	}
}

func TestSendKeys(t *testing.T) {
	session := testSession(t)
	CreateSession(session, "main")
	// Just verify it doesn't error - we can't easily verify the keys were received
	if err := SendKeys(session, "main", "echo hello"); err != nil {
		t.Fatalf("SendKeys() error: %v", err)
	}
}

func TestWindowExistsWithBellPrefix(t *testing.T) {
	session := testSession(t)
	CreateSession(session, "main")
	dir := t.TempDir()
	CreateWindow(session, "notified", dir)
	RenameWindow(session, "notified", "ðŸ”” notified")
	// WindowExists should find the window by its base name
	if !WindowExists(session, "notified") {
		t.Error("WindowExists should find window with bell prefix")
	}
}
```

**Step 2: Run tests to verify they fail**

Run:
```bash
cd orchestrator && go test ./internal/tmux/
```
Expected: Compilation error â€” package has no Go files yet.

**Step 3: Write implementation**

```go
package tmux

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

const bellPrefix = "ðŸ”” "

// SessionExists checks if a tmux session exists.
func SessionExists(name string) bool {
	cmd := exec.Command("tmux", "has-session", "-t", name)
	return cmd.Run() == nil
}

// CreateSession creates a new tmux session with an initial window.
func CreateSession(name, windowName string) error {
	cmd := exec.Command("tmux", "new-session", "-d", "-s", name, "-n", windowName)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("tmux new-session failed: %s", strings.TrimSpace(string(out)))
	}
	return nil
}

// WindowExists checks if a tmux window exists, handling bell prefix.
func WindowExists(session, window string) bool {
	windows, err := ListWindows(session)
	if err != nil {
		return false
	}
	for _, w := range windows {
		if w == window || w == bellPrefix+window {
			return true
		}
	}
	return false
}

// ActualWindowName returns the real window name (with or without bell prefix), or empty string if not found.
func ActualWindowName(session, window string) string {
	windows, err := ListWindows(session)
	if err != nil {
		return ""
	}
	for _, w := range windows {
		if w == window {
			return window
		}
		if w == bellPrefix+window {
			return bellPrefix + window
		}
	}
	return ""
}

// CreateWindow creates a new tmux window in the given session.
func CreateWindow(session, window, cwd string) error {
	cmd := exec.Command("tmux", "new-window", "-t", session, "-n", window, "-c", cwd, "-d")
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("tmux new-window failed: %s", strings.TrimSpace(string(out)))
	}
	return nil
}

// KillWindow closes a tmux window.
func KillWindow(session, window string) error {
	cmd := exec.Command("tmux", "kill-window", "-t", session+":"+window)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("tmux kill-window failed: %s", strings.TrimSpace(string(out)))
	}
	return nil
}

// KillSession kills an entire tmux session.
func KillSession(name string) error {
	cmd := exec.Command("tmux", "kill-session", "-t", name)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("tmux kill-session failed: %s", strings.TrimSpace(string(out)))
	}
	return nil
}

// SendKeys sends keystrokes to a tmux window.
func SendKeys(session, window, command string) error {
	cmd := exec.Command("tmux", "send-keys", "-t", session+":"+window, command, "C-m")
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("tmux send-keys failed: %s", strings.TrimSpace(string(out)))
	}
	return nil
}

// RenameWindow renames a tmux window.
func RenameWindow(session, oldName, newName string) error {
	cmd := exec.Command("tmux", "rename-window", "-t", session+":"+oldName, newName)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("tmux rename-window failed: %s", strings.TrimSpace(string(out)))
	}
	return nil
}

// ListWindows returns the names of all windows in a session.
func ListWindows(session string) ([]string, error) {
	cmd := exec.Command("tmux", "list-windows", "-t", session, "-F", "#{window_name}")
	out, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("tmux list-windows failed: %w", err)
	}
	raw := strings.TrimSpace(string(out))
	if raw == "" {
		return nil, nil
	}
	return strings.Split(raw, "\n"), nil
}

// Attach attaches to a tmux session. If already inside tmux, switches client.
func Attach(session string) error {
	if os.Getenv("TMUX") != "" {
		cmd := exec.Command("tmux", "switch-client", "-t", session)
		cmd.Stdin = os.Stdin
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		return cmd.Run()
	}
	cmd := exec.Command("tmux", "attach-session", "-t", session)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
cd orchestrator && go test ./internal/tmux/ -v
```
Expected: All 8 tests pass.

**Step 5: Commit**

```bash
git add orchestrator/internal/tmux/
git commit -m "feat(cco): add tmux package for session and window management"
```

---

### Task 5: Session package

**Files:**
- Create: `orchestrator/internal/session/session.go`

This package orchestrates the other packages. It will be tested via integration tests in Task 7 (testing through the CLI binary, matching CWM's integration test strategy). Unit testing here would require mocking git and tmux which adds complexity without much value.

**Step 1: Write implementation**

```go
package session

import (
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/averycrespi/claudefiles/orchestrator/internal/git"
	"github.com/averycrespi/claudefiles/orchestrator/internal/paths"
	"github.com/averycrespi/claudefiles/orchestrator/internal/tmux"
)

// Init ensures a tmux session exists for the repository.
func Init(repoRoot string) error {
	info, err := git.RepoInfo(repoRoot)
	if err != nil {
		return err
	}
	if info.IsWorktree {
		return fmt.Errorf("this command must be run from the main git repository, not a worktree")
	}

	sessionName := paths.TmuxSessionName(info.Name)
	if tmux.SessionExists(sessionName) {
		fmt.Printf("tmux session already exists: %s\n", sessionName)
		return nil
	}

	fmt.Printf("Creating tmux session: %s with main window\n", sessionName)
	return tmux.CreateSession(sessionName, "main")
}

// Add creates a new session: worktree, tmux window, setup, and Claude launch.
func Add(repoRoot, branch string) error {
	info, err := git.RepoInfo(repoRoot)
	if err != nil {
		return err
	}
	if info.IsWorktree {
		return fmt.Errorf("this command must be run from the main git repository, not a worktree")
	}

	// Ensure tmux session exists
	if err := Init(repoRoot); err != nil {
		return err
	}

	sessionName := paths.TmuxSessionName(info.Name)
	windowName := paths.TmuxWindowName(branch)
	sessionDir := paths.SessionDir(info.Name, branch)

	// Create worktree if it doesn't exist
	if _, err := os.Stat(sessionDir); os.IsNotExist(err) {
		fmt.Printf("Creating worktree at: %s\n", sessionDir)
		if err := os.MkdirAll(filepath.Dir(sessionDir), 0o755); err != nil {
			return fmt.Errorf("could not create session directory: %w", err)
		}
		if err := git.AddWorktree(info.Root, sessionDir, branch); err != nil {
			return err
		}
	} else {
		fmt.Printf("Worktree already exists at: %s\n", sessionDir)
	}

	// Run setup scripts if found
	fmt.Println("Searching for setup scripts ...")
	runSetupScripts(sessionDir)

	// Copy local Claude settings if they exist
	copyLocalSettings(info.Root, sessionDir)

	// Create tmux window if it doesn't exist
	if tmux.WindowExists(sessionName, windowName) {
		fmt.Printf("tmux window already exists: %s\n", windowName)
	} else {
		fmt.Printf("Creating tmux window: %s\n", windowName)
		if err := tmux.CreateWindow(sessionName, windowName, sessionDir); err != nil {
			return err
		}
		fmt.Println("Launching Claude Code")
		if err := tmux.SendKeys(sessionName, windowName, "claude --permission-mode acceptEdits"); err != nil {
			return err
		}
	}

	return nil
}

// Remove removes a session: worktree and tmux window.
func Remove(repoRoot, branch string) error {
	info, err := git.RepoInfo(repoRoot)
	if err != nil {
		return err
	}
	if info.IsWorktree {
		return fmt.Errorf("this command must be run from the main git repository, not a worktree")
	}

	sessionName := paths.TmuxSessionName(info.Name)
	windowName := paths.TmuxWindowName(branch)
	sessionDir := paths.SessionDir(info.Name, branch)

	// Remove worktree if it exists
	if _, err := os.Stat(sessionDir); os.IsNotExist(err) {
		fmt.Printf("Worktree does not exist at: %s\n", sessionDir)
	} else {
		fmt.Printf("Removing worktree at: %s\n", sessionDir)
		if err := git.RemoveWorktree(info.Root, sessionDir); err != nil {
			return err
		}
	}

	// Close tmux window if it exists
	if !tmux.SessionExists(sessionName) {
		fmt.Printf("tmux session does not exist: %s\n", sessionName)
		return nil
	}

	actualName := tmux.ActualWindowName(sessionName, windowName)
	if actualName != "" {
		fmt.Printf("Closing tmux window: %s\n", windowName)
		return tmux.KillWindow(sessionName, actualName)
	}
	fmt.Printf("tmux window does not exist: %s\n", windowName)
	return nil
}

// Attach attaches to the tmux session for the repository at the given path.
// Works from both the main repo and worktrees.
func Attach(path string) error {
	info, err := git.RepoInfo(path)
	if err != nil {
		return err
	}

	// If we're in a worktree, we need the main repo name.
	// RepoInfo gives us the worktree root, but we need the main repo name.
	// For worktrees created by cco, the session dir structure is:
	//   ~/.local/share/cco/sessions/{repo}/{branch}/
	// But for attach, we derive the session name from the repo name.
	// Since worktrees share the same git-common-dir, we can derive the main repo info.
	var repoName string
	if info.IsWorktree {
		// Derive main repo from git-common-dir
		cmd := exec.Command("git", "rev-parse", "--git-common-dir")
		cmd.Dir = path
		out, err := cmd.Output()
		if err != nil {
			return fmt.Errorf("could not determine main repo: %w", err)
		}
		commonDir := filepath.Clean(filepath.Join(path, string(out[:len(out)-1])))
		mainRoot := filepath.Dir(commonDir) // strip .git
		repoName = filepath.Base(mainRoot)
	} else {
		repoName = info.Name
	}

	sessionName := paths.TmuxSessionName(repoName)

	if !tmux.SessionExists(sessionName) {
		if info.IsWorktree {
			return fmt.Errorf("tmux session does not exist: %s. Run 'cco init' from the main repository first", sessionName)
		}
		if err := Init(path); err != nil {
			return err
		}
	}

	fmt.Printf("Attaching to tmux session: %s\n", sessionName)
	return tmux.Attach(sessionName)
}

// Notify adds a bell emoji to the tmux window for the current session.
// Designed to be called from hooks â€” prints skip reason to stderr and always returns nil.
func Notify(path string) error {
	info, err := git.RepoInfo(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Skipped: %v\n", err)
		return nil
	}

	if !info.IsWorktree {
		fmt.Fprintln(os.Stderr, "Skipped: This command must be run from a worktree, not the main repository")
		return nil
	}

	// Derive session info from the worktree path.
	// For cco-managed worktrees, the path is:
	//   ~/.local/share/cco/sessions/{repo}/{branch}/
	// Parse repo and branch from the path structure.
	sessionsDir := filepath.Join(paths.DataDir(), "sessions")
	relPath, err := filepath.Rel(sessionsDir, info.Root)
	if err != nil || relPath == "." || relPath[:2] == ".." {
		fmt.Fprintf(os.Stderr, "Skipped: Worktree path '%s' is not under cco sessions directory\n", info.Root)
		return nil
	}

	parts := filepath.SplitList(relPath)
	// Use filepath.Split to get repo/branch
	dir, branch := filepath.Split(relPath)
	repoName := filepath.Clean(dir)
	if repoName == "" || branch == "" {
		fmt.Fprintf(os.Stderr, "Skipped: Could not parse repo/branch from path '%s'\n", info.Root)
		return nil
	}

	sessionName := paths.TmuxSessionName(repoName)
	_ = parts

	if !tmux.SessionExists(sessionName) {
		fmt.Fprintf(os.Stderr, "Skipped: tmux session '%s' does not exist\n", sessionName)
		return nil
	}

	windowName := branch
	windows, err := tmux.ListWindows(sessionName)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Skipped: Could not list windows for session '%s'\n", sessionName)
		return nil
	}

	bellName := "ðŸ”” " + windowName
	for _, w := range windows {
		if w == bellName {
			fmt.Printf("tmux window '%s' already has a notification\n", windowName)
			return nil
		}
	}

	for _, w := range windows {
		if w == windowName {
			fmt.Printf("Adding notification to tmux window: %s\n", windowName)
			if err := tmux.RenameWindow(sessionName, windowName, bellName); err != nil {
				fmt.Fprintf(os.Stderr, "Skipped: Could not rename tmux window '%s'\n", windowName)
			}
			return nil
		}
	}

	fmt.Fprintf(os.Stderr, "Skipped: tmux window '%s' does not exist\n", windowName)
	return nil
}

// runSetupScripts looks for and runs setup scripts in the session directory.
func runSetupScripts(sessionDir string) {
	scriptsDir := filepath.Join(sessionDir, "scripts")
	candidates := []string{"init", "init.sh", "setup", "setup.sh"}

	for _, name := range candidates {
		scriptPath := filepath.Join(scriptsDir, name)
		fi, err := os.Stat(scriptPath)
		if err != nil || fi.IsDir() {
			continue
		}
		// Check if executable
		if fi.Mode()&0o111 == 0 {
			continue
		}
		fmt.Printf("Running setup script: %s\n", scriptPath)
		cmd := exec.Command(scriptPath)
		cmd.Dir = sessionDir
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: setup script %s failed: %v\n", name, err)
		}
		return // Run only the first matching script (matches CWM behavior of first-match-wins)
	}
	fmt.Println("No setup scripts found")
}

// copyLocalSettings copies .claude/settings.local.json from the main repo to the session dir.
func copyLocalSettings(repoRoot, sessionDir string) {
	src := filepath.Join(repoRoot, ".claude", "settings.local.json")
	dst := filepath.Join(sessionDir, ".claude", "settings.local.json")

	srcFile, err := os.Open(src)
	if err != nil {
		fmt.Println("No local Claude settings found in repo")
		return
	}
	defer srcFile.Close()

	if _, err := os.Stat(dst); err == nil {
		fmt.Println("Local Claude settings already exist in worktree")
		return
	}

	fmt.Printf("Copying local Claude settings to: %s\n", dst)
	if err := os.MkdirAll(filepath.Dir(dst), 0o755); err != nil {
		fmt.Fprintf(os.Stderr, "Warning: could not create .claude dir: %v\n", err)
		return
	}
	dstFile, err := os.Create(dst)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: could not create settings file: %v\n", err)
		return
	}
	defer dstFile.Close()
	io.Copy(dstFile, srcFile)
}
```

**Step 2: Verify it compiles**

Run:
```bash
cd orchestrator && go build ./internal/session/
```
Expected: Compiles without errors.

**Step 3: Commit**

```bash
git add orchestrator/internal/session/
git commit -m "feat(cco): add session package for orchestrating session lifecycle"
```

---

### Task 6: CLI commands

**Files:**
- Modify: `orchestrator/cmd/root.go`
- Create: `orchestrator/cmd/init.go`
- Create: `orchestrator/cmd/add.go`
- Create: `orchestrator/cmd/rm.go`
- Create: `orchestrator/cmd/attach.go`
- Create: `orchestrator/cmd/notify.go`

**Step 1: Write init command**

```go
package cmd

import (
	"fmt"
	"os"

	"github.com/averycrespi/claudefiles/orchestrator/internal/session"
	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Create tmux session for the current repository",
	Long:  "Create a tmux session with a 'main' window. Safe to run multiple times. Must be run from the main repository, not a worktree.",
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("could not get working directory: %w", err)
		}
		return session.Init(cwd)
	},
}

func init() {
	rootCmd.AddCommand(initCmd)
}
```

**Step 2: Write add command**

```go
package cmd

import (
	"fmt"
	"os"

	"github.com/averycrespi/claudefiles/orchestrator/internal/session"
	"github.com/spf13/cobra"
)

var addCmd = &cobra.Command{
	Use:   "add <branch>",
	Short: "Create a session and launch Claude Code",
	Long:  "Create a git worktree, tmux window, run setup scripts, and launch Claude Code. Creates the branch if it doesn't exist. Must be run from the main repository.",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("could not get working directory: %w", err)
		}
		return session.Add(cwd, args[0])
	},
}

func init() {
	rootCmd.AddCommand(addCmd)
}
```

**Step 3: Write rm command**

```go
package cmd

import (
	"fmt"
	"os"

	"github.com/averycrespi/claudefiles/orchestrator/internal/session"
	"github.com/spf13/cobra"
)

var rmCmd = &cobra.Command{
	Use:   "rm <branch>",
	Short: "Remove a session and close its tmux window",
	Long:  "Remove the git worktree and close the tmux window for the given branch. Safe to run if either has already been removed. Must be run from the main repository.",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("could not get working directory: %w", err)
		}
		return session.Remove(cwd, args[0])
	},
}

func init() {
	rootCmd.AddCommand(rmCmd)
}
```

**Step 4: Write attach command**

```go
package cmd

import (
	"fmt"
	"os"

	"github.com/averycrespi/claudefiles/orchestrator/internal/session"
	"github.com/spf13/cobra"
)

var attachCmd = &cobra.Command{
	Use:   "attach",
	Short: "Attach to the tmux session for the current repository",
	Long:  "Attach to (or switch to) the worktree session. Works from both the main repo and worktrees.",
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("could not get working directory: %w", err)
		}
		return session.Attach(cwd)
	},
}

func init() {
	rootCmd.AddCommand(attachCmd)
}
```

**Step 5: Write notify command**

```go
package cmd

import (
	"fmt"
	"os"

	"github.com/averycrespi/claudefiles/orchestrator/internal/session"
	"github.com/spf13/cobra"
)

var notifyCmd = &cobra.Command{
	Use:   "notify",
	Short: "Add notification bell to current session's tmux window",
	Long:  "Add a bell emoji prefix to the tmux window name. Designed for hooks; exits 0 even when skipping. Must be run from a worktree.",
	RunE: func(cmd *cobra.Command, args []string) error {
		cwd, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("could not get working directory: %w", err)
		}
		return session.Notify(cwd)
	},
}

func init() {
	rootCmd.AddCommand(notifyCmd)
}
```

**Step 6: Build and verify help output**

Run:
```bash
cd orchestrator && go build -o cco . && ./cco --help
```
Expected: Help output showing all 5 subcommands: init, add, rm, attach, notify.

**Step 7: Commit**

```bash
git add orchestrator/cmd/
git commit -m "feat(cco): add CLI commands for init, add, rm, attach, notify"
```

---

### Task 7: Integration tests

**Files:**
- Create: `orchestrator/integration_test.go`

These tests mirror the existing CWM integration tests in `tests/test_cwm.py`. They build the `cco` binary and run it as a subprocess against real git repos and tmux sessions.

**Step 1: Write integration tests**

```go
package main

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

var ccoBinary string

func TestMain(m *testing.M) {
	// Build the binary once for all tests
	tmpDir, err := os.MkdirTemp("", "cco-test-bin")
	if err != nil {
		panic(err)
	}
	ccoBinary = filepath.Join(tmpDir, "cco")
	cmd := exec.Command("go", "build", "-o", ccoBinary, ".")
	cmd.Dir = "." // orchestrator directory
	if out, err := cmd.CombinedOutput(); err != nil {
		panic("failed to build cco: " + string(out))
	}
	code := m.Run()
	os.RemoveAll(tmpDir)
	os.Exit(code)
}

// helper: create a temp git repo with an initial commit
func setupRepo(t *testing.T) string {
	t.Helper()
	dir := t.TempDir()
	runCmd(t, dir, "git", "init")
	runCmd(t, dir, "git", "commit", "--allow-empty", "-m", "init")
	return dir
}

func runCmd(t *testing.T, dir, name string, args ...string) string {
	t.Helper()
	cmd := exec.Command(name, args...)
	cmd.Dir = dir
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("%s %v failed: %s\n%s", name, args, err, out)
	}
	return strings.TrimSpace(string(out))
}

func runCCO(t *testing.T, dir string, args ...string) (string, string, int) {
	t.Helper()
	cmd := exec.Command(ccoBinary, args...)
	cmd.Dir = dir
	var stdout, stderr strings.Builder
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	err := cmd.Run()
	exitCode := 0
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			exitCode = exitErr.ExitCode()
		} else {
			t.Fatalf("cco %v failed unexpectedly: %v", args, err)
		}
	}
	return stdout.String(), stderr.String(), exitCode
}

func tmuxSessionName(repoDir string) string {
	return filepath.Base(repoDir) + "-worktree"
}

func tmuxSessionExists(session string) bool {
	cmd := exec.Command("tmux", "has-session", "-t", session)
	return cmd.Run() == nil
}

func tmuxListWindows(t *testing.T, session string) []string {
	t.Helper()
	cmd := exec.Command("tmux", "list-windows", "-t", session, "-F", "#{window_name}")
	out, err := cmd.Output()
	if err != nil {
		return nil
	}
	raw := strings.TrimSpace(string(out))
	if raw == "" {
		return nil
	}
	return strings.Split(raw, "\n")
}

func killTmuxSession(session string) {
	exec.Command("tmux", "kill-session", "-t", session).Run()
}

func sessionDir(t *testing.T, repoDir, branch string) string {
	t.Helper()
	// Matches paths.SessionDir logic
	home, _ := os.UserHomeDir()
	dataDir := os.Getenv("XDG_DATA_HOME")
	if dataDir == "" {
		dataDir = filepath.Join(home, ".local", "share")
	}
	// Sanitize branch: replace non-alphanumeric (except hyphen) with hyphen
	sanitized := sanitizeBranch(branch)
	return filepath.Join(dataDir, "cco", "sessions", filepath.Base(repoDir), sanitized)
}

func sanitizeBranch(branch string) string {
	var b strings.Builder
	for _, r := range branch {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '-' {
			b.WriteRune(r)
		} else {
			b.WriteRune('-')
		}
	}
	return b.String()
}

// --- Tests ---

func TestSmoke(t *testing.T) {
	stdout, _, code := runCCO(t, ".", "--help")
	if code != 0 {
		t.Fatalf("cco --help exited %d", code)
	}
	if !strings.Contains(stdout, "cco") {
		t.Error("help output should contain 'cco'")
	}
}

func TestInitOutsideGitRepo(t *testing.T) {
	dir := t.TempDir()
	_, stderr, code := runCCO(t, dir, "init")
	if code == 0 {
		t.Error("init should fail outside git repo")
	}
	if !strings.Contains(stderr, "not a git repository") {
		t.Errorf("expected 'not a git repository' in stderr, got: %s", stderr)
	}
}

func TestAddOutsideGitRepo(t *testing.T) {
	dir := t.TempDir()
	_, stderr, code := runCCO(t, dir, "add", "some-branch")
	if code == 0 {
		t.Error("add should fail outside git repo")
	}
	if !strings.Contains(stderr, "not a git repository") {
		t.Errorf("expected 'not a git repository' in stderr, got: %s", stderr)
	}
}

func TestRmOutsideGitRepo(t *testing.T) {
	dir := t.TempDir()
	_, stderr, code := runCCO(t, dir, "rm", "some-branch")
	if code == 0 {
		t.Error("rm should fail outside git repo")
	}
	if !strings.Contains(stderr, "not a git repository") {
		t.Errorf("expected 'not a git repository' in stderr, got: %s", stderr)
	}
}

func TestInit(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() { killTmuxSession(session) })

	if tmuxSessionExists(session) {
		t.Fatal("session should not exist before init")
	}

	stdout, _, code := runCCO(t, dir, "init")
	if code != 0 {
		t.Fatalf("init exited %d", code)
	}
	if !strings.Contains(stdout, "Creating tmux session") {
		t.Error("expected 'Creating tmux session' in output")
	}
	if !tmuxSessionExists(session) {
		t.Error("session should exist after init")
	}
	windows := tmuxListWindows(t, session)
	if !contains(windows, "main") {
		t.Errorf("expected 'main' window, got: %v", windows)
	}
}

func TestInitIdempotent(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() { killTmuxSession(session) })

	runCCO(t, dir, "init")
	stdout, _, code := runCCO(t, dir, "init")
	if code != 0 {
		t.Fatalf("second init exited %d", code)
	}
	if !strings.Contains(stdout, "already exists") {
		t.Error("expected 'already exists' on second init")
	}
}

func TestAddNewBranch(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() {
		killTmuxSession(session)
		os.RemoveAll(sessionDir(t, dir, "test-branch"))
	})

	_, _, code := runCCO(t, dir, "add", "test-branch")
	if code != 0 {
		t.Fatalf("add exited %d", code)
	}

	// Verify worktree directory exists
	sd := sessionDir(t, dir, "test-branch")
	if _, err := os.Stat(sd); os.IsNotExist(err) {
		t.Errorf("session dir should exist at %s", sd)
	}

	// Verify tmux window exists
	windows := tmuxListWindows(t, session)
	if !contains(windows, "test-branch") {
		t.Errorf("expected 'test-branch' window, got: %v", windows)
	}
}

func TestAddExistingBranch(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() {
		killTmuxSession(session)
		os.RemoveAll(sessionDir(t, dir, "existing-branch"))
	})

	runCmd(t, dir, "git", "branch", "existing-branch")
	_, _, code := runCCO(t, dir, "add", "existing-branch")
	if code != 0 {
		t.Fatalf("add exited %d", code)
	}

	sd := sessionDir(t, dir, "existing-branch")
	if _, err := os.Stat(sd); os.IsNotExist(err) {
		t.Error("session dir should exist")
	}
	windows := tmuxListWindows(t, session)
	if !contains(windows, "existing-branch") {
		t.Errorf("expected 'existing-branch' window, got: %v", windows)
	}
}

func TestAddIdempotent(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() {
		killTmuxSession(session)
		os.RemoveAll(sessionDir(t, dir, "idem-branch"))
	})

	runCCO(t, dir, "add", "idem-branch")
	stdout, _, code := runCCO(t, dir, "add", "idem-branch")
	if code != 0 {
		t.Fatalf("second add exited %d", code)
	}
	if !strings.Contains(stdout, "already exists") {
		t.Error("expected 'already exists' on second add")
	}
}

func TestRm(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() {
		killTmuxSession(session)
		os.RemoveAll(sessionDir(t, dir, "rm-branch"))
	})

	runCCO(t, dir, "add", "rm-branch")
	sd := sessionDir(t, dir, "rm-branch")
	if _, err := os.Stat(sd); os.IsNotExist(err) {
		t.Fatal("session dir should exist before rm")
	}

	_, _, code := runCCO(t, dir, "rm", "rm-branch")
	if code != 0 {
		t.Fatalf("rm exited %d", code)
	}

	if _, err := os.Stat(sd); !os.IsNotExist(err) {
		t.Error("session dir should not exist after rm")
	}
	windows := tmuxListWindows(t, session)
	if contains(windows, "rm-branch") {
		t.Error("rm-branch window should not exist after rm")
	}
}

func TestRmIdempotent(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() { killTmuxSession(session) })

	runCCO(t, dir, "add", "rm-idem")
	runCCO(t, dir, "rm", "rm-idem")

	stdout, _, code := runCCO(t, dir, "rm", "rm-idem")
	if code != 0 {
		t.Fatalf("second rm exited %d", code)
	}
	if !strings.Contains(stdout, "does not exist") {
		t.Error("expected 'does not exist' on second rm")
	}
}

func TestNotifyFromMainRepo(t *testing.T) {
	dir := setupRepo(t)
	_, stderr, code := runCCO(t, dir, "notify")
	if code != 0 {
		t.Fatalf("notify exited %d", code)
	}
	if !strings.Contains(stderr, "Skipped") {
		t.Error("expected 'Skipped' in stderr when notify run from main repo")
	}
}

func TestNotifyFromWorktree(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() {
		killTmuxSession(session)
		os.RemoveAll(sessionDir(t, dir, "notify-branch"))
	})

	runCCO(t, dir, "add", "notify-branch")
	sd := sessionDir(t, dir, "notify-branch")

	stdout, _, code := runCCO(t, sd, "notify")
	if code != 0 {
		t.Fatalf("notify exited %d", code)
	}
	if !strings.Contains(stdout, "Adding notification") {
		t.Errorf("expected 'Adding notification' in stdout, got: %s", stdout)
	}

	windows := tmuxListWindows(t, session)
	if !contains(windows, "ðŸ”” notify-branch") {
		t.Errorf("expected bell-prefixed window, got: %v", windows)
	}
}

func TestNotifyIdempotent(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() {
		killTmuxSession(session)
		os.RemoveAll(sessionDir(t, dir, "notify-idem"))
	})

	runCCO(t, dir, "add", "notify-idem")
	sd := sessionDir(t, dir, "notify-idem")

	runCCO(t, sd, "notify")
	stdout, _, code := runCCO(t, sd, "notify")
	if code != 0 {
		t.Fatalf("second notify exited %d", code)
	}
	if !strings.Contains(stdout, "already has a notification") {
		t.Error("expected 'already has a notification' on second notify")
	}

	// Verify no double bell
	windows := tmuxListWindows(t, session)
	if contains(windows, "ðŸ”” ðŸ”” notify-idem") {
		t.Error("should not have double bell prefix")
	}
}

func TestBranchNameSanitization(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() {
		killTmuxSession(session)
		os.RemoveAll(sessionDir(t, dir, "feat/my-thing"))
	})

	_, _, code := runCCO(t, dir, "add", "feat/my-thing")
	if code != 0 {
		t.Fatalf("add exited %d", code)
	}

	sd := sessionDir(t, dir, "feat/my-thing")
	if _, err := os.Stat(sd); os.IsNotExist(err) {
		t.Error("session dir should exist")
	}
	windows := tmuxListWindows(t, session)
	if !contains(windows, "feat-my-thing") {
		t.Errorf("expected 'feat-my-thing' window, got: %v", windows)
	}
}

func TestAddCopiesLocalSettings(t *testing.T) {
	dir := setupRepo(t)
	session := tmuxSessionName(dir)
	t.Cleanup(func() {
		killTmuxSession(session)
		os.RemoveAll(sessionDir(t, dir, "settings-branch"))
	})

	// Create local settings in the main repo
	claudeDir := filepath.Join(dir, ".claude")
	os.MkdirAll(claudeDir, 0o755)
	os.WriteFile(filepath.Join(claudeDir, "settings.local.json"), []byte(`{"test": true}`), 0o644)

	_, _, code := runCCO(t, dir, "add", "settings-branch")
	if code != 0 {
		t.Fatalf("add exited %d", code)
	}

	sd := sessionDir(t, dir, "settings-branch")
	copied := filepath.Join(sd, ".claude", "settings.local.json")
	data, err := os.ReadFile(copied)
	if err != nil {
		t.Fatalf("could not read copied settings: %v", err)
	}
	if string(data) != `{"test": true}` {
		t.Errorf("copied settings = %q, want %q", string(data), `{"test": true}`)
	}
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
```

**Step 2: Run tests**

Run:
```bash
cd orchestrator && go test -v -count=1 -timeout 60s
```
Expected: All tests pass. Some tests may need minor adjustments based on exact error message formatting from cobra.

**Step 3: Commit**

```bash
git add orchestrator/integration_test.go
git commit -m "test(cco): add integration tests mirroring CWM test coverage"
```

---

### Task 8: Build and install setup

**Files:**
- Modify: `setup.sh`
- Modify: `CLAUDE.md`
- Modify: `README.md`

**Step 1: Update setup.sh to build cco**

Add after the `brew bundle` line and before the stow line:

```bash
echo 'Building cco (Claude Code Orchestrator) ...'
REPO_DIR=$(git rev-parse --show-toplevel)
(cd "$REPO_DIR/orchestrator" && go build -o "$REPO_DIR/scripts/cco" .)
```

This builds the `cco` binary into the `scripts/` directory, which is already on the user's PATH.

**Step 2: Update README.md**

In the Requirements section, add Go to the requirements list:
```
- [Go](https://go.dev/) 1.21+ for building `cco`
```

In the "Claude Worktree Manager" section, add a new section after it:

```markdown
## Claude Code Orchestrator (NEW)

`cco` (Claude Code Orchestrator) manages parallel Claude Code sessions using Git worktrees and tmux. It replaces `cwm` with centralized session storage.

| Command              | Purpose                                  |
| -------------------- | ---------------------------------------- |
| `cco init`           | Create tmux session for repo             |
| `cco add <branch>`   | Create session + launch Claude           |
| `cco rm <branch>`    | Remove session + close window            |
| `cco attach`         | Attach to tmux session for repo          |
| `cco notify`         | Add bell to window (for hooks)           |

Sessions are stored at `~/.local/share/cco/sessions/{repo}/{branch}/`.
```

**Step 3: Update CLAUDE.md**

Add cco commands table alongside cwm in the Worktree Management section. Add to the Scripts table or add a new section:

```markdown
### Session Management (cco)

| Command              | Purpose                                                                     |
| -------------------- | --------------------------------------------------------------------------- |
| `cco init`           | Start a new tmux session for the current repository                         |
| `cco add <branch>`   | Create a session (worktree + window) and launch Claude Code                 |
| `cco rm <branch>`    | Remove a session (worktree + window)                                        |
| `cco attach`         | Attach to the tmux session for the current repository                       |
| `cco notify`         | Add notification bell to tmux window for the current session                |
```

Add to the Testing section:

```markdown
Run cco integration tests (requires tmux and Go):

\`\`\`bash
cd orchestrator && go test -v -count=1 -timeout 60s
\`\`\`
```

**Step 4: Add scripts/cco to .gitignore**

The built binary should not be committed. Create or update `.gitignore`:

```
scripts/cco
```

**Step 5: Verify setup.sh works**

Run:
```bash
./setup.sh
```
Expected: cco binary built at `scripts/cco`, `cco --help` works.

**Step 6: Commit**

```bash
git add setup.sh CLAUDE.md README.md .gitignore
git commit -m "chore: add cco build to setup and update documentation"
```

---

### Task 9: Add Go to Brewfile

**Files:**
- Modify: `Brewfile`

**Step 1: Check if Go is already in Brewfile**

Read `Brewfile` and check. If not present, add:

```ruby
brew "go"
```

**Step 2: Commit**

```bash
git add Brewfile
git commit -m "chore: add go to Brewfile"
```
