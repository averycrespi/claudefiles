#!/usr/bin/env python3

"""
Secure replacement for the find command with safety checks.

Safely wrapping the find command is non-trival, so it's
easier to reimplement its core functionality here.

Requirements:
- MUST NOT support dangerous operations like -exec, -delete, -ok
- MUST validate all inputs for security
- MUST limit resource usage to prevent abuse
- MUST provide clear error messages for blocked operations

Usage: safe-find [path...] [options]
"""

import os
import sys
import argparse
import fnmatch
import stat
import time
import re

# Maximum recursion depth to prevent excessive resource usage
MAX_DEPTH = 50

# Maximum number of files to process
MAX_FILES = 100_000

# Dangerous operations that are explicitly blocked
BLOCKED_OPTIONS = {
    "-exec",
    "-execdir",
    "-delete",
    "-ok",
    "-okdir",
    "-prune",
    "-quit",
    "-fprint",
    "-fprintf",
    "-fls",
    "-printf",
}


def parse_arguments():
    """Parse command line arguments with safety validation."""
    parser = argparse.ArgumentParser(
        description="Secure find replacement, which cannot execute commands or modify files.",
        add_help=False,  # We'll handle help manually to match find behavior
    )

    # Check for blocked operations first
    for arg in sys.argv[1:]:
        if arg in BLOCKED_OPTIONS:
            print(
                f"Error: Option '{arg}' is not supported for security reasons",
                file=sys.stderr,
            )
            print("Supported options:", file=sys.stderr)
            print("  -name PATTERN     Find files matching pattern", file=sys.stderr)
            print("  -iname PATTERN    Case-insensitive name matching", file=sys.stderr)
            print(
                "  -type TYPE        File type (f=file, d=directory, l=symlink)",
                file=sys.stderr,
            )
            print("  -size [+-]N[cwbkMG]  File size filter", file=sys.stderr)
            print("  -mtime [+-]N      Modification time in days", file=sys.stderr)
            print("  -maxdepth N       Maximum search depth", file=sys.stderr)
            print("  -mindepth N       Minimum search depth", file=sys.stderr)
            print("  -print            Print results (default)", file=sys.stderr)
            print(
                "  -print0           Print results separated by null bytes",
                file=sys.stderr,
            )
            sys.exit(1)

    # Paths (can be multiple)
    parser.add_argument(
        "paths",
        nargs="*",
        default=["."],
        help="Directories to search (default: current directory)",
    )

    # Search criteria
    parser.add_argument(
        "-name", dest="name_pattern", help="Base of filename matches pattern"
    )
    parser.add_argument(
        "-iname", dest="iname_pattern", help="Case-insensitive name matching"
    )
    parser.add_argument(
        "-type",
        choices=["f", "d", "l"],
        help="File type: f=file, d=directory, l=symlink",
    )
    parser.add_argument(
        "-size", dest="size_filter", help="File size filter (e.g., +1M, -100k)"
    )
    parser.add_argument(
        "-mtime", dest="mtime_filter", type=int, help="Modified time filter in days"
    )
    parser.add_argument(
        "-maxdepth",
        type=int,
        default=MAX_DEPTH,
        help=f"Maximum search depth (max: {MAX_DEPTH})",
    )
    parser.add_argument("-mindepth", type=int, default=0, help="Minimum search depth")

    # Output options
    parser.add_argument(
        "-print", action="store_true", default=True, help="Print results (default)"
    )
    parser.add_argument(
        "-print0", action="store_true", help="Print results separated by null bytes"
    )
    parser.add_argument("-help", action="store_true", help="Show this help message")

    args = parser.parse_args()

    if args.help:
        parser.print_help()
        sys.exit(0)

    # Validate depth limits
    if args.maxdepth > MAX_DEPTH:
        print(
            f"Error: Maximum depth limited to {MAX_DEPTH} for security", file=sys.stderr
        )
        sys.exit(1)

    if args.mindepth < 0:
        print("Error: Minimum depth cannot be negative", file=sys.stderr)
        sys.exit(1)

    if args.mindepth > args.maxdepth:
        print("Error: Minimum depth cannot exceed maximum depth", file=sys.stderr)
        sys.exit(1)

    # Validate paths exist
    for path in args.paths:
        if not os.path.exists(path):
            print(f"Error: Path '{path}' does not exist", file=sys.stderr)
            sys.exit(1)

    return args


def parse_size_filter(size_str):
    """Parse size filter string like '+1M', '-100k', '50c'."""
    if not size_str:
        return None

    # Extract operator, number, and unit
    match = re.match(r"^([+-]?)(\d+)([cwbkMG]?)$", size_str)
    if not match:
        print(f"Error: Invalid size format '{size_str}'", file=sys.stderr)
        sys.exit(1)

    operator, number, unit = match.groups()
    number = int(number)

    # Convert to bytes
    multipliers = {
        "c": 1,
        "w": 2,
        "b": 512,
        "k": 1024,
        "M": 1024 * 1024,
        "G": 1024 * 1024 * 1024,
    }
    multiplier = multipliers.get(unit, 1)
    size_bytes = number * multiplier

    return (operator, size_bytes)


def matches_criteria(filepath, filename, file_stat, args, current_depth):
    """Check if file matches all specified criteria."""
    # Check depth constraints
    if current_depth < args.mindepth or current_depth > args.maxdepth:
        return False

    # Check name pattern
    if args.name_pattern and not fnmatch.fnmatch(filename, args.name_pattern):
        return False

    if args.iname_pattern and not fnmatch.fnmatch(
        filename.lower(), args.iname_pattern.lower()
    ):
        return False

    # Check file type
    if args.type:
        if args.type == "f" and not stat.S_ISREG(file_stat.st_mode):
            return False
        elif args.type == "d" and not stat.S_ISDIR(file_stat.st_mode):
            return False
        elif args.type == "l" and not stat.S_ISLNK(file_stat.st_mode):
            return False

    # Check size filter
    if args.size_filter:
        size_info = parse_size_filter(args.size_filter)
        if size_info:
            operator, target_size = size_info
            file_size = file_stat.st_size

            if operator == "+" and file_size <= target_size:
                return False
            elif operator == "-" and file_size >= target_size:
                return False
            elif operator == "" and file_size != target_size:
                return False

    # Check modification time
    if args.mtime_filter is not None:
        file_mtime = file_stat.st_mtime
        current_time = time.time()
        days_ago = (current_time - file_mtime) / (24 * 3600)

        if args.mtime_filter > 0 and days_ago < args.mtime_filter:
            return False
        elif args.mtime_filter < 0 and days_ago > abs(args.mtime_filter):
            return False
        elif args.mtime_filter == 0 and int(days_ago) != 0:
            return False

    return True


def safe_find(args):
    """Main find logic with safety constraints, streaming results to stdout."""
    files_processed = 0
    separator = "\0" if args.print0 else "\n"

    for search_path in args.paths:
        try:
            for root, dirs, files in os.walk(search_path):
                # Calculate current depth relative to search path
                current_depth = root[len(search_path) :].count(os.sep)
                if search_path != "." and not search_path.endswith(os.sep):
                    current_depth += 1

                # Stop if we exceed max depth
                if current_depth > args.maxdepth:
                    dirs.clear()  # Don't descend further
                    continue

                # Check directory itself if it matches criteria
                try:
                    dir_stat = os.lstat(root)
                    if matches_criteria(
                        root, os.path.basename(root), dir_stat, args, current_depth
                    ):
                        print(root, end=separator)
                        files_processed += 1
                        if files_processed > MAX_FILES:
                            print(
                                f"Error: Too many files (limit: {MAX_FILES})",
                                file=sys.stderr,
                            )
                            sys.exit(1)
                except (OSError, IOError):
                    continue  # Skip inaccessible directories

                # Check files in directory
                for filename in files:
                    filepath = os.path.join(root, filename)
                    try:
                        file_stat = os.lstat(filepath)
                        if matches_criteria(
                            filepath, filename, file_stat, args, current_depth
                        ):
                            print(filepath, end=separator)
                            files_processed += 1
                            if files_processed > MAX_FILES:
                                print(
                                    f"Error: Too many files (limit: {MAX_FILES})",
                                    file=sys.stderr,
                                )
                                sys.exit(1)
                    except (OSError, IOError):
                        continue  # Skip inaccessible files

        except (OSError, IOError) as e:
            print(f"Error accessing '{search_path}': {e}", file=sys.stderr)
            continue


def main():
    """Main entry point."""
    try:
        args = parse_arguments()
        safe_find(args)

    except KeyboardInterrupt:
        print("\nInterrupted", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
