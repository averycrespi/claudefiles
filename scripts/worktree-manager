#!/usr/bin/env python3

"""
Claude Code Git Worktree Manager (Python Version)
This script will be called by Claude Code custom slash commands.
"""

import os
import sys
import subprocess
import re
import time


class Sanitizer:
    def sanitize_path(self, path, allow_relative=False):
        """Sanitize a file system path for security issues."""
        if not path or not isinstance(path, str):
            raise ValueError("Path must be a non-empty string")

        if "\x00" in path:
            raise ValueError("Path contains null bytes")

        if ".." in path:
            raise ValueError("Path contains parent directory references")

        if not allow_relative and not os.path.isabs(path):
            raise ValueError("Relative paths not allowed")

        if len(path) > 4096:
            raise ValueError("Path too long")

        normalized = os.path.normpath(path)
        if normalized != path and not allow_relative:
            raise ValueError("Path normalization changed the path")

        return normalized

    def sanitize_branch_name(self, branch_name):
        """Sanitize a git branch name."""
        if not branch_name or not isinstance(branch_name, str):
            raise ValueError("Branch name must be a non-empty string")

        if branch_name.startswith(".") or branch_name.endswith("."):
            raise ValueError("Branch name cannot start or end with '.'")

        if branch_name.startswith("-") or branch_name.endswith("-"):
            raise ValueError("Branch name cannot start or end with '-'")

        if ".." in branch_name:
            raise ValueError("Branch name cannot contain '..'")

        if branch_name.endswith(".lock"):
            raise ValueError("Branch name cannot end with '.lock'")

        forbidden_chars = set(
            "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
            "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
            " ~^:?*[\\@{}\x7f"
        )
        if any(c in forbidden_chars for c in branch_name):
            raise ValueError("Branch name contains forbidden characters")

        if len(branch_name) > 250:  # Conservative limit
            raise ValueError("Branch name too long")

        return branch_name

    def sanitize_command_string(self, command):
        """Sanitize a command string for tmux send-keys."""
        if not isinstance(command, str):
            raise ValueError("Command must be a string")

        if "\x00" in command:
            raise ValueError("Command contains null bytes")

        forbidden_sequences = [
            "\x1b",  # ESC
            "\x03",  # Ctrl-C
            "\x04",  # Ctrl-D
            "\x0c",  # Ctrl-L
            "\x01",  # Ctrl-A
        ]
        if any(seq in command for seq in forbidden_sequences):
            raise ValueError("Command contains control characters")

        if len(command) > 8192:
            raise ValueError("Command too long")

        return command

    def sanitize_tmux_name(self, name):
        """Sanitize a tmux session or window name name."""
        if not name or not isinstance(name, str):
            raise ValueError("Name must be a non-empty string")

        return re.sub(r"[^a-zA-Z0-9._-]", "-", name)


class Logger:
    class Colors:
        GREEN = "\033[0;32m"
        BLUE = "\033[0;34m"
        YELLOW = "\033[1;33m"
        RED = "\033[0;31m"
        NC = "\033[0m"

    def info(self, message):
        print(f"{self.Colors.BLUE}INFO{self.Colors.NC}: {message}", file=sys.stderr)

    def success(self, message):
        print(f"{self.Colors.GREEN}SUCCESS{self.Colors.NC}: {message}", file=sys.stderr)

    def error(self, message):
        print(f"{self.Colors.RED}ERROR{self.Colors.NC}: {message}", file=sys.stderr)

    def warning(self, message):
        print(
            f"{self.Colors.YELLOW}WARNING{self.Colors.NC}: {message}", file=sys.stderr
        )


class Shell:
    def run(self, cmd_args, capture_output=False, raise_on_error=True):
        """Run a command with arguments; shell input is DISABLED for security."""
        if capture_output:
            return subprocess.run(
                cmd_args,
                text=True,
                check=raise_on_error,
                capture_output=True,
            )
        else:
            return subprocess.run(
                cmd_args,
                text=True,
                check=raise_on_error,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )


class Git:
    class GitError(Exception):
        pass

    def __init__(self, *, shell, sanitizer):
        if not shell:
            raise ValueError("Shell instance is required")
        if not sanitizer:
            raise ValueError("Sanitizer instance is required")
        self.shell = shell
        self.sanitizer = sanitizer

    def is_git_repo(self):
        """Check if the current directory is a git repository."""
        result = self.shell.run(
            ["git", "rev-parse", "--is-inside-work-tree"],
            raise_on_error=False,
        )
        return result and result.returncode == 0

    def get_repo_root(self):
        """Get the root of the git repository."""
        result = self.shell.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True,
        )
        if result and result.stdout:
            return result.stdout.strip()
        raise self.GitError(f"failed to get repo root")

    def get_repo_name(self):
        """Get the name of the git repository."""
        return os.path.basename(self.get_repo_root())

    def branch_exists_locally(self, branch_name):
        """Check if branch exists locally."""
        try:
            # Validate branch name first - if invalid, it can't exist
            self.sanitizer.sanitize_branch_name(branch_name)
        except ValueError:
            return False

        branch_name = self.sanitizer.sanitize_tmux_name(branch_name)
        result = self.shell.run(
            ["git", "show-ref", "--verify", "--quiet", f"refs/heads/{branch_name}"],
            raise_on_error=False,
        )
        return result and result.returncode == 0

    def branch_exists_remotely(self, branch_name):
        """Check if branch exists on remote."""
        try:
            # Validate branch name first - if invalid, it can't exist
            self.sanitizer.sanitize_branch_name(branch_name)
        except ValueError:
            return False

        branch_name = self.sanitizer.sanitize_tmux_name(branch_name)
        result = self.shell.run(
            [
                "git",
                "show-ref",
                "--verify",
                "--quiet",
                f"refs/remotes/origin/{branch_name}",
            ],
            raise_on_error=False,
        )
        return result and result.returncode == 0

    def create_worktree(self, *, worktree_dir, branch_name, new_branch=False):
        """Create a git worktree."""
        worktree_dir = self.sanitizer.sanitize_path(worktree_dir, allow_relative=True)
        branch_name = self.sanitizer.sanitize_branch_name(branch_name)

        if new_branch:
            self.shell.run(
                ["git", "worktree", "add", "-b", branch_name, worktree_dir],
            )
        else:
            self.shell.run(
                ["git", "worktree", "add", worktree_dir, branch_name],
            )

    def remove_worktree(self, worktree_dir):
        """Remove a git worktree."""
        worktree_dir = self.sanitizer.sanitize_path(worktree_dir, allow_relative=True)
        self.shell.run(["git", "worktree", "remove", worktree_dir])

    def prune_worktrees(self):
        """Prune orphaned worktrees."""
        self.shell.run(["git", "worktree", "prune"])

    def list_worktrees(self):
        """List git worktrees."""
        result = self.shell.run(
            ["git", "worktree", "list"],
            capture_output=True,
        )
        if not result:
            raise self.GitError(f"failed to list worktrees")

        if not result.stdout:
            return []

        return result.stdout.strip().split("\n")

    def worktree_exists(self, worktree_path):
        """Check if a worktree exists at the given path."""
        worktree_path = self.sanitizer.sanitize_path(worktree_path, allow_relative=True)
        worktrees = self.list_worktrees()

        for worktree_line in worktrees:
            # Each line is like: "/path/to/worktree  abc123 [branch_name]"
            # Extract just the path part (everything before the first space)
            line_path = worktree_line.strip().split()[0] if worktree_line.strip() else ""
            if line_path == worktree_path:
                return True

        return False


class Tmux:
    class TmuxError(Exception):
        pass

    def __init__(self, *, shell, session_name, base_window_name, sanitizer):
        if not shell:
            raise ValueError("Shell instance is required")
        if not session_name or not isinstance(session_name, str):
            raise ValueError("Session name must be a non-empty string")
        if not base_window_name or not isinstance(base_window_name, str):
            raise ValueError("Base window name must be a non-empty string")
        if not sanitizer:
            raise ValueError("Sanitizer instance is required")

        self.shell = shell
        self.sanitizer = sanitizer
        self.session_name = self.sanitizer.sanitize_tmux_name(session_name)
        self.base_window_name = self.sanitizer.sanitize_tmux_name(base_window_name)

    def session_exists(self):
        """Check if a tmux session exists."""
        result = self.shell.run(
            ["tmux", "has-session", "-t", self.session_name],
            raise_on_error=False,
        )
        return result and result.returncode == 0

    def create_session(self):
        """Create a new detached tmux session."""
        self.shell.run(
            [
                "tmux",
                "new-session",
                "-d",
                "-s",
                self.session_name,
                "-n",
                self.base_window_name,
            ]
        )

    def window_exists(self, window_name):
        """Check if a tmux window exists."""
        window_name = self.sanitizer.sanitize_tmux_name(window_name)
        result = self.shell.run(
            ["tmux", "list-windows", "-t", self.session_name, "-F", "#{window_name}"],
            capture_output=True,
        )
        if not result:
            raise self.TmuxError(f"failed to check if window exists")

        if result.stdout is None:
            raise self.TmuxError(f"failed to check if window exists")

        return window_name in result.stdout.strip().split("\n")

    def create_window(self, window_name):
        """Create a new tmux window."""
        window_name = self.sanitizer.sanitize_tmux_name(window_name)
        self.shell.run(
            ["tmux", "new-window", "-t", self.session_name, "-n", window_name]
        )

    def select_window(self, window_name):
        """Switch to a tmux window."""
        window_name = self.sanitizer.sanitize_tmux_name(window_name)
        self.shell.run(
            ["tmux", "select-window", "-t", f"{self.session_name}:{window_name}"]
        )

    def kill_window(self, window_name):
        """Kill a tmux window."""
        window_name = self.sanitizer.sanitize_tmux_name(window_name)
        self.shell.run(
            ["tmux", "kill-window", "-t", f"{self.session_name}:{window_name}"]
        )

    def send_keys(self, *, window_name, command, enter=False):
        """Send keys to a tmux window."""
        window_name = self.sanitizer.sanitize_tmux_name(window_name)
        command = self.sanitizer.sanitize_command_string(command)

        args = [
            "tmux",
            "send-keys",
            "-t",
            f"{self.session_name}:{window_name}",
            command,
        ]
        if enter:
            args.append("C-m")

        self.shell.run(args)


class Manager:
    def __init__(self, *, git, tmux, logger, sanitizer):
        if not git:
            raise ValueError("Git instance is required")
        if not tmux:
            raise ValueError("Tmux instance is required")
        if not logger:
            raise ValueError("Logger instance is required")
        if not sanitizer:
            raise ValueError("Sanitizer instance is required")

        self.git = git
        self.tmux = tmux
        self.logger = logger
        self.sanitizer = sanitizer

    def create_worktree(self, name, prompt=None):
        """Create a new worktree and tmux window."""
        try:
            branch_name = self.sanitizer.sanitize_branch_name(name)
            window_name = self.sanitizer.sanitize_tmux_name(name)

            repo_root = self.git.get_repo_root()
            repo_name = self.git.get_repo_name()

            worktree_path = os.path.join(
                os.path.dirname(repo_root), f"{repo_name}-worktree-{branch_name}"
            )

            if self.git.worktree_exists(worktree_path):
                self.logger.warning(f"Worktree already exists at: {worktree_path}")
            else:
                self.logger.info(f"Creating worktree at: {worktree_path}")
                branch_exists = self.git.branch_exists_locally(branch_name)
                self.git.create_worktree(
                    worktree_dir=worktree_path,
                    branch_name=branch_name,
                    new_branch=not branch_exists,
                )

            if not self.tmux.session_exists():
                self.logger.info(f"Creating tmux session: {self.tmux.session_name}")
                self.tmux.create_session()

            if self.tmux.window_exists(window_name):
                self.logger.success(f"tmux window: {window_name} already exists")
                return

            self.logger.info(f"Creating tmux window: {window_name}")
            self.tmux.create_window(window_name)

            self.logger.info(f"Changing to worktree directory: {worktree_path}")
            self.tmux.send_keys(
                window_name=window_name, command=f"cd {worktree_path}", enter=True
            )

            self.logger.info(f"Starting Claude Code in worktree window: {window_name}")
            self.tmux.send_keys(
                window_name=window_name,
                command=f"claude --add-dir '{worktree_path}' --permission-mode acceptEdits",
                enter=True,
            )

            self.logger.info("Bypassing directory trust prompt")
            time.sleep(2)
            self.tmux.send_keys(window_name=window_name, command="", enter=True)

            if prompt:
                self.logger.info(f"Sending prompt to Claude Code")
                prompt = self.sanitizer.sanitize_command_string(prompt)
                self.tmux.send_keys(window_name=window_name, command=prompt)
                time.sleep(0.1)
                self.tmux.send_keys(window_name=window_name, command="", enter=True)

            self.logger.success(
                f"Created worktree at: {worktree_path} with tmux window: {window_name}"
            )

        except Exception as e:
            self.logger.error(f"Failed to create worktree: {e}")

    def destroy_worktree(self, name):
        """Destroy a worktree and its associated tmux window."""
        try:
            window_name = self.sanitizer.sanitize_tmux_name(name)

            repo_root = self.git.get_repo_root()
            repo_name = self.git.get_repo_name()

            worktree_path = os.path.join(
                os.path.dirname(repo_root), f"{repo_name}-worktree-{window_name}"
            )

            if not self.git.worktree_exists(worktree_path):
                self.logger.warning(f"Worktree does not exist at: {worktree_path}")
            else:
                self.logger.info(f"Removing worktree at: {worktree_path}")
                self.git.remove_worktree(worktree_path)

            if self.tmux.session_exists():
                if self.tmux.window_exists(window_name):
                    self.logger.info(f"Killing tmux window: {window_name}")
                    self.tmux.kill_window(window_name)
                else:
                    self.logger.warning(f"Tmux window: {window_name} does not exist")
            else:
                self.logger.warning("Tmux session does not exist")

            self.logger.info("Pruning orphaned worktrees")
            self.git.prune_worktrees()

            self.logger.success(
                f"Destroyed worktree at path: {worktree_path} with tmux window: {window_name}"
            )

        except Exception as e:
            self.logger.error(f"Failed to destroy worktree: {e}")


def main():
    """Main CLI entry point."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Git worktree manager with tmux integration",
        prog="worktree-manager",
    )

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    create_parser = subparsers.add_parser(
        "create", help="Create a new worktree with tmux window"
    )
    create_parser.add_argument("name", help="Name for the worktree and tmux window")
    create_parser.add_argument(
        "prompt",
        nargs=argparse.REMAINDER,
        help="Optional prompt to send to Claude Code",
    )

    destroy_parser = subparsers.add_parser(
        "destroy", help="Destroy a worktree and its tmux window"
    )
    destroy_parser.add_argument(
        "name", help="Name of the worktree and tmux window to destroy"
    )

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    sanitizer = Sanitizer()
    logger = Logger()
    shell = Shell()
    git = Git(shell=shell, sanitizer=sanitizer)

    tmux = Tmux(
        shell=shell,
        sanitizer=sanitizer,
        session_name="worktree-manager",
        base_window_name="orchestrator",
    )

    manager = Manager(git=git, tmux=tmux, logger=logger, sanitizer=sanitizer)

    if not git.is_git_repo():
        logger.error("Not in a git repository")
        sys.exit(1)

    if args.command == "create":
        manager.create_worktree(args.name, " ".join(args.prompt))
    elif args.command == "destroy":
        manager.destroy_worktree(args.name)


if __name__ == "__main__":
    main()
